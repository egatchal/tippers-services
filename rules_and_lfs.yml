# Rules and Labeling Functions Configuration
# Postman-ready JSON bodies for device classification concept
#
# Concept value IDs (create these first):
#   cv_id=1: STATIC (Intermittent static device)
#   cv_id=2: LAPTOP (Weekday 9AM-9PM connections)
#   cv_id=3: PHONE (Short daily sessions)

# ============================================================================
# Rules — POST /concepts/{c_id}/rules
# Pure feature extraction, no label awareness
# ============================================================================

rules:
  # POST /concepts/{c_id}/rules
  - name: "static_short_irregular_sessions_rule"
    index_id: 1
    sql_query: |
      WITH connections AS (SELECT mac_address, SUM(CASE WHEN EXTRACT(EPOCH FROM (end_time - start_time)) / 3600 <= 2 THEN 1 ELSE 0 END) * 1.0 / COUNT(*) AS connection_count, COUNT(DISTINCT(space_id)) AS distinct_ap FROM user_location_trajectory WHERE mac_address IN (:index_values) GROUP BY mac_address) SELECT mac_address, connection_count, distinct_ap FROM connections;
    index_column: "mac_address"

  # POST /concepts/{c_id}/rules
  - name: "laptop_total_connected_duration_rule"
    index_id: 1
    sql_query: |
      WITH total_sessions AS (SELECT * FROM user_location_trajectory WHERE mac_address IN (:index_values)), total_connection_count AS (SELECT mac_address, COUNT(*) AS total_count FROM total_sessions GROUP BY mac_address), valid_connections AS (SELECT mac_address FROM total_sessions WHERE EXTRACT(DOW FROM start_time) BETWEEN 1 AND 5 AND EXTRACT(HOUR FROM start_time) >= 9 AND EXTRACT(HOUR FROM end_time) <= 21), valid_connection_count AS (SELECT mac_address, COUNT(*) AS valid_count FROM valid_connections GROUP BY mac_address), valid_connection_percentage AS (SELECT t.mac_address, v.valid_count * 1.0 / NULLIF(t.total_count, 0) AS percentage FROM total_connection_count t JOIN valid_connection_count v ON t.mac_address = v.mac_address) SELECT mac_address, percentage FROM valid_connection_percentage;
    index_column: "mac_address"

  # POST /concepts/{c_id}/rules
  - name: "phone_1_hour_average_rule"
    index_id: 1
    sql_query: |
      WITH total_sessions AS (SELECT * FROM user_location_trajectory WHERE mac_address IN (:index_values)), daily_avg_connection_time AS (SELECT mac_address, DATE(start_time) AS day, SUM(EXTRACT(EPOCH FROM (end_time - start_time))) / COUNT(*) / 3600.0 AS avg_hours_per_connection FROM total_sessions GROUP BY mac_address, DATE(start_time)), matched_days AS (SELECT mac_address, day FROM daily_avg_connection_time WHERE avg_hours_per_connection <= 1), user_day_counts AS (SELECT d.mac_address, COUNT(DISTINCT d.day) AS total_days, COUNT(DISTINCT m.day) AS qualifying_days FROM daily_avg_connection_time d LEFT JOIN matched_days m ON d.mac_address = m.mac_address AND d.day = m.day GROUP BY d.mac_address), qualified_users AS (SELECT mac_address, total_days FROM user_day_counts WHERE qualifying_days * 1.0 / total_days >= 0.8 AND total_days >= 1) SELECT mac_address, total_days FROM qualified_users;
    index_column: "mac_address"


# ============================================================================
# Labeling Functions — POST /concepts/{c_id}/labeling-functions
# Custom Python only, with multi-CV support
# ============================================================================

labeling_functions:
  # POST /concepts/{c_id}/labeling-functions
  - name: "static_short_irregular_sessions_lf"
    rule_id: 1
    applicable_cv_ids: [1, 2, 3]
    code: |
      STATIC = 1
      ABSTAIN = -1

      def labeling_function(row):
          if row['connection_count'] >= 0.8 and row['distinct_ap'] == 1:
              return STATIC
          return ABSTAIN
    allowed_imports: []

  # POST /concepts/{c_id}/labeling-functions
  - name: "laptop_total_connected_duration_lf"
    rule_id: 2
    applicable_cv_ids: [1, 2, 3]
    code: |
      LAPTOP = 2
      ABSTAIN = -1

      def labeling_function(row):
          if row['percentage'] >= 0.8:
              return LAPTOP
          return ABSTAIN
    allowed_imports: []

  # POST /concepts/{c_id}/labeling-functions
  - name: "phone_1_hour_average_lf"
    rule_id: 3
    applicable_cv_ids: [1, 2, 3]
    code: |
      PHONE = 3
      ABSTAIN = -1

      def labeling_function(row):
          if row['total_days'] >= 1:
              return PHONE
          return ABSTAIN
    allowed_imports: []


# Notes:
# -------------------------
# 1. Each rule/LF entry above can be copied directly as a JSON body in Postman.
#    Just convert YAML to JSON (keys are the same as the Pydantic schema fields).
#
# 2. LFs now return cv_id values (e.g., STATIC=1, LAPTOP=2, PHONE=3) or ABSTAIN=-1.
#    The Dagster snorkel_training asset remaps cv_ids to 0-indexed class labels.
#
# 3. applicable_cv_ids on LFs declares which concept values the LF may vote on.
#    Snorkel cardinality is determined from the union of all selected LFs' applicable_cv_ids.
#
# 4. Rules are pure feature extraction with no label awareness.
#    applicable_cv_ids and label_guidance have been removed from rules.
#
# 5. To use this configuration:
#    a) Create concept values: STATIC (cv_id=1), LAPTOP (cv_id=2), PHONE (cv_id=3)
#    b) Create an index that samples mac_addresses from user_location_trajectory
#    c) Create rules using POST /concepts/{c_id}/rules with the entries above
#    d) Materialize each rule
#    e) Create LFs using POST /concepts/{c_id}/labeling-functions with the entries above
#    f) Approve each LF via POST /concepts/{c_id}/labeling-functions/{lf_id}/approve
#    g) Run Snorkel training with selected LFs
